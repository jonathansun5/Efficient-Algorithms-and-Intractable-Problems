% Search for all the places that say "PUT SOMETHING HERE".

\documentclass[11pt]{article}
\usepackage{amsmath,textcomp,amssymb,graphicx,enumerate,hyperref,enumitem,mathtools,tikz-qtree,listings,tikz}
\definecolor{light-gray}{gray}{0.85}
\lstset{
    numbers=left,
    breaklines=true,
    backgroundcolor=\color{light-gray},
    tabsize=2,
    basicstyle=\ttfamily,
    literate={\ \ }{{\ }}1
}

\def\Name{Jonathan Sun}  % Your name
\def\SID{25020651}  % Your student ID number
\def\Homework{7} % Number of Homework
\def\Session{Fall 2017}


\title{CS170 --- \Session --- Homework \Homework \space Solutions}
\author{\Name, SID \SID}
\markboth{CS170 --- \Session --- Homework \Homework \space --- \Name}{CS170 --- \Session --- Homework \Homework --- \Name}
\pagestyle{myheadings}
\date{}

\def\endproofmark{$\Box$}
\newenvironment{proof}{\par{\bf Proof:}}{\endproofmark\smallskip}
\newenvironment{FourPartSolution}{\par{\bf Four-Part Solution:}}{\smallskip}
\newenvironment{mainIdea}{\par{\bf Main Idea:}}{\smallskip}
\newenvironment{pseudocode}{\par{\bf Pseudocode:}}{\smallskip}
\newenvironment{proofOfCorrectness}{\par{\bf Proof of Correctness:}}{\endproofmark\smallskip}
\newenvironment{runTime}{\par{\bf Run Time:}}{\smallskip}
\newenvironment{justification}{\par{\bf Justification:}}{\smallskip}
% \newenvironment{proofOfCorrectness}{\par{\bf Proof of Correctness:}}{\endproofmark\smallskip}
% \newenvironment{runTime}{\par{\bf Run Time:}}{\smallskip}
% \newenvironment{justification}{\par{\bf Justification:}}{\smallskip}

\usepackage[margin=1in]{geometry}



\begin{document}
\maketitle

\section*{0. Who Did You Work With?}

Collaborators: Kevin Vo, Aleem Zaki, Jeremy Ou



\newpage
\section*{1. A HeLPful Introduction}
\begin{enumerate}[label=(\alph*)]
\item
The necessary and sufficient conditions on real numbers $a$ and $b$ that make the linear program infeasible do not exist. This is because no matter what $a$ and $b$ are, $x$ and $y$ can both equal $0$ and this will always satisfy the constraints.



\item
The necessary and sufficient conditions on real numbers $a$ and $b$ that make the linear program unbounded are if $a < 0$ or $b < 0$. This is because the conditions to maximize $x + y$ and $ax + by \leq 1$ with either $a < 0$ or $b < 0$ would make the region's area infinite. In other words, if the slope of the line for $ax + by \leq 1$ is positive, then there is no maximum for either $x$ or $y$ making the region's area infinite. If the slope of the line is negative, then both $x$ and $y$ will have individual maximum values and so $x + y$ will be bounded. Therefore, the to make the linear program unbounded, either $a$ or $b$ will need to be less than zero to make the slope positive.



\item
The necessary and sufficient conditions on real numbers $a$ and $b$ that allow the linear program to have a unique optimal solution are that $a > 0$, $b > 0$, and $a \neq b$. This allows for the slope of the line for $ax + by \leq 1$ to be negative, which will give individual maximum bounds to both $x$ and $y$. Furthermore, $a \leq b$ makes the slope not equal to $-1$, which would cause the maximum value of $x$ to equal the maximum value of $y$. This would give multiple solutions since $max x + y$ would all be the same value if the slope is $-1$. Therefore, we need the slope to be negative and also not equal to $-1$.
\end{enumerate}



\newpage
\section*{2. TeaOne}
\begin{enumerate}[label=(\alph*)]
\item
The cost of creating a ZestyJuice is $5 \times 0.1 + 1 \times 0.2 + 8 \times 0.01 = 0.78$. Since a ZestyJuice sells for $4.5$, the profit of selling one is $4.5 - 0.78 = 3.72$. The cost of creating a MilkTea is $12 \times 0.1 + 16 \times 0.2 = 4.4$. Since a MilkTea sells for $5$, the profit of selling one is $5 - 4.4 = 0.6$. With this, I will represent ZestyJuice as $z$ and MilkTea as $m$. The linear program will be:
\begin{align*}
\text{max } 3.72 z + 0.6 m
\end{align*}
\begin{align*}
z \leq 60
\end{align*}
\begin{align*}
m \leq 40
\end{align*}
\begin{align*}
0.78 z + 4.4 m \leq b
\end{align*}
\begin{align*}
z \geq 0 \text{, } m \geq 0
\end{align*}



\item
\begin{align*}
\text{min } 60 y_1 + 40 y_2 + 6 y_3
\end{align*}
\begin{align*}
y_1 + 0.78 y_3 \geq 3.72
\end{align*}
\begin{align*}
y_2 + 4.4 y_3 \geq 0.6
\end{align*}
\begin{align*}
y_1 \geq 0 \text{, } y_2 \geq 0 \text{, } y_3 \geq 0
\end{align*}
\item
There are three types of solutions for this part since we can have a budget that is so large that we can afford to make all $60$ ZestyJuice and $40$ MilkyTea, a limited budget so we maximize ZestyJuices since they make the most profit, and another limited budget where we maximize MilkyTea because they turn a profit.
\begin{align*}
z = \frac{b} {0.78} \text{, } m = 0 \text{ for } b < 46.8
\end{align*}
\begin{align*}
z = 60 \text{, } m = \frac{b - 46.8} {4.4} \text{ for } 46.8 \leq b \leq 222.8
\end{align*}
\begin{align*}
z = 60 \text{, } m = 40 \text{ for } b > 222.8
\end{align*}
\end{enumerate}



\newpage
\section*{3. Mountain pass}
\begin{enumerate}[label=(\alph*)]
\item




\item






\end{enumerate}



\newpage
\section*{4. The Hungry Caterpillar}
\begin{FourPartSolution}
\\
\begin{mainIdea}
\\
The main idea to solve this is to use a graph traversal algorithm to get to $k$ distinct branch points. However, since it costs energy to travel from one branch to the next and we need to start and end at the same point, this means that the caterpillar will be forced to return back to the start point by expending more energy. Since the process of going back on a traversal just costs energy without allowing the caterpillar to eat, this should be avoided as much as possible, except when the caterpillar has to return back to start. Therefore, the caterpillar's path should try to traverse as far down as possible and try to avoid as many backwards movement as possible. To do this, there will be a penalty imposed on each backwards movement the algorithm takes to discourage the caterpillar from traversing backwards in general.
\end{mainIdea}
\\
\begin{pseudocode}
\begin{lstlisting}
shortestPathsDFS(G, len, s, t):
	dist(s) = 0
	# initialize a priority queue starting from s and length of 0
	Q = stack[(s, 0)]
	maxCount = 0
	count = 0
	minStack = Null
	while Q is not empty:
		# u = path and v = dist
		u, v = Q.pop()
		if u = t:
			# 1 + count because we popped one already
			count += 1
			if count > maxCount:
				maxCount = count
				minStack.add(node)
			return 1 + count((t, v) left in the queue)
		for edges(u, v) in E:
			Q.add((v, val + len(u, v))
	return minStack

\end{lstlisting}
\end{pseudocode}
\begin{proofOfCorrectness}
\\
It should be correct because we are just modifying DFS but making it greedy by keeping a counter of the number of back traversals done to discourage the back traversals. 
\end{proofOfCorrectness}
\\
\begin{runTime}
\\
$O(3n)$.
\end{runTime}
\\
\begin{justification}
\\
The runtime is $O(3n)$ because the graph traversal will take $O(|V| + |E|)$ time. Since each vertex can either have $2$ branches or none, the number of edges will be equal to double the number of vertices. Since the number of vertices is $k$ and it is upper bounded by $n$, the number of vertices is upper bounded by $n$ and the number of edges is upper bounded by $2n$. Therefore, the runtime is $O(n + |E|) = O(n + |V - 1|) = O(n + 2|V|) = O(n + 2n) = O(3n)$.
\end{justification}
\end{FourPartSolution}



\newpage
\section*{5. Star-shaped polygons in 2D}
The idea for this problem is that the point $x$ will be able to see all the points of the polygon, which means that there can be a direct line between each point of the polygon to the point $x$ and none of these points will intersect or be the same equation as each other between each point of the polygon and $x$. In other words, the linear program needs to show whether there exists a point $x$ that is the intersection of all the lines that go from each point of the polygon to $x$. This can further "simplified" by having the linear program show whether there exists a point $x$ that is the intersection of all the lines that go from each CORNER of the polygon to $x$. \\
\vspace*{1\baselineskip}
Therefore, the linear program can be represented as:
\begin{align*}
\text{max } None
\end{align*}
\begin{align*}
a_i x + b_i y > c_i \text{ where } i \in \{1, 2, ..., n - 1\}
\end{align*}



\newpage
\section*{6. All Knight-er}
\begin{FourPartSolution}
\\
\begin{mainIdea}
\\
The main idea is that a knight can only attack in a "L" shape where it needs to move $2$ spaces on one axis and $1$ space on another axis. So, the idea is that the subproblems will be to find the number of ways we can add more knights given the previous row and the one before that since all the other rows before those two rows will not affect the next row since we just need to care about the previous $2$ rows.
\end{mainIdea}
\\
\begin{pseudocode}
\begin{lstlisting}
function AllKnighter(M, N):
	state1 = none
	state2 = none
	count = 0
	for all M's:
		if positionSoFar == 2:
			count += 1
			# only one way to put knight when increasing the column size by 2
			return AllKnighterActual(1, 2, state1, state2)

	function AllKnighterActual(sum, positionSoFar, state1, state2):
		while positionSoFar < N:
			for all M's:
				AllKnighterActual(sum, positionSoFar, state0, state1).sum += AllKnighterActual(sum, positionSoFar - 1, state2, state3).sum
				count += AllKnighterActual(sum, positionSoFar, state0, state1).sum
		return AllKnighterActual(sum, positionSoFar, state0, state1)

	return count
\end{lstlisting}
\end{pseudocode}
\begin{proofOfCorrectness}
\\
To show that the idea for the pseudocode is correct, I will start with the base case, which is also my first conditional in the for-loop for AllKnighter. This part means that for every size of $M$, I will increase the count by $1$ because in a $M$ by $N$ board, every $M$ by $2$ has $1$ new valid knight placement assuming that the previous two rows had valid placements since the $2$ previous rows limit the new placements that can be be made at the next row. Therefore, to use this idea, I need to be able to keep the previous $2$ row's information (which I call state1 and state2) as I am considering the number of possible placements for the new state. Doing so means that for every new row that I look at, I will count the number of possible knight placements in that row and add it to the sum I got when working on the previous row.
\end{proofOfCorrectness}
\\
\begin{runTime}
\\
$O(2^{3M} N)$.
\end{runTime}
\\
\begin{justification}
\\
The runtime is $O(2^{3M} N)$ because the number of times I call AllKnighterActual is $2^{2M} N$ times since the $2M$ comes from the $2$ recursive calls for all $M$ in the for loop of all $M$. Since the while loop has $N$ iterations, there are $2^{2M} N$ subproblems. However, there is also time to compute each occurance of $M$ in the outer function, which takes $2^M$ time. Therefore, the total runtime is $O(2^{2M} N \times 2^M) = O(2^{3M} N)$.
\end{justification}
\end{FourPartSolution}
\end{document}
